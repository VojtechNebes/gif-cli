#!/usr/bin/env python

from PIL import Image, UnidentifiedImageError
import time, os
import argparse, sys
import pathlib


def _resizeImage(image: Image.Image, max_size):
    """Resize the image while maintaining aspect ratio."""
    image.thumbnail(max_size, Image.LANCZOS)
    return image

def _processGif(input_path, output_size: tuple[int, int]) -> list[tuple[Image.Image, float]]:
    try:
        with Image.open(input_path) as img:
            frames = []
            try:
                while True:
                    # Get the current frame and resize it
                    frame = _resizeImage(img.copy(), output_size)
                    
                    # Append the resized frame to the frames list
                    frames.append((frame, frame.info["duration"]))
                    
                    # Move to the next frame
                    img.seek(img.tell() + 1)
            except EOFError:
                pass  # that was the last frame

            return frames
    except (UnidentifiedImageError, IsADirectoryError, FileNotFoundError) as e:
        print(e)
        sys.exit(1)

def _printImage(image: Image.Image):
    pixels = image.load()

    rows = []

    for y in range(image.size[1]):
        row = ""

        for x in range(image.size[0]):
            pixel = pixels[x, y]

            row += f"\033[48;2;{pixel[0]};{pixel[1]};{pixel[2]}m" + "  "
        
        rows.append(row)
    
    # print everything at once to prevent tearing when stopped
    print("\n".join(rows))

def run(frames: list[tuple[Image.Image, float]], delay: float):
    try:
        for i, frame in enumerate(frames):
            if i == 0: continue # skip first frame for some reason

            image = frame[0]

            _printImage(image)
            
            # go back at the start of the gif to overwrite the lines next frame
            print(f"\033[{image.size[1]}A", end="")

            time.sleep(delay or frame[1]/1000) # when delay is None, use delay from gif
    except KeyboardInterrupt:
        sys.exit(0)



if __name__ != "__main__": sys.exit()



parser = argparse.ArgumentParser(description="display a gif in the terminal", conflict_handler="resolve")

parser.add_argument(
    "gif",
    type=pathlib.Path,
    help="Path to the gif file to display."
)

parser.add_argument(
    "-f",
    "--forever",
    dest="forever",
    action='store_true',
    help="Keep looping the gif until ^C is pressed."
)

parser.add_argument(
    "-d",
    "--delay",
    dest="delay",
    type=float,
    help="Delay between frames in seconds. When not specified, the delay is read from the gif file."
)

terminalWidth, terminalHeight = os.get_terminal_size()

parser.add_argument(
    "-w",
    "--width",
    dest="width",
    type=int,
    default=terminalWidth,
    help="Maximum width of the output."
)

parser.add_argument(
    "-h",
    "--height",
    dest="height",
    type=int,
    default=terminalHeight-1,
    help="Maximum height of the output."
)

args = parser.parse_args()

frames = _processGif(args.gif.resolve(), (args.width, args.height))

# get height of the gif frame
height = frames[0][0].size[1]

# "allocate" this many empty lines
# this is to prevent issues with automatic scrolling
print("\n"*(height), end="")
print(f"\033[{height}A", end="")

# turn of echo
os.system("stty -echo")

# display the gif forever or once
if args.forever:
    while True:
        run(frames, args.delay)
else:
    run(frames, args.delay)